/* jshint quotmark: false */
'use strict';

var FS = require('fs'),
    PATH = require('path'),
    chalk = require('chalk'),
    mkdirp = require('mkdirp'),
    promisify = require('util.promisify'),
    readdir = promisify(FS.readdir),
    readFile = promisify(FS.readFile),
    writeFile = promisify(FS.writeFile),
    SVGO = require('../svgo.js'),
    YAML = require('js-yaml'),
    PKG = require('../../package.json'),
    encodeSVGDatauri = require('./tools.js').encodeSVGDatauri,
    decodeSVGDatauri = require('./tools.js').decodeSVGDatauri,
    checkIsDir = require('./tools.js').checkIsDir,
    regSVGFile = /\.svg$/,
    noop = () => {},
    svgo;

/**
 * Command-Option-Argument.
 *
 * @see https://github.com/veged/coa
 */
module.exports = require('coa').Cmd()
    .helpful()
    .name(PKG.name)
    .title(PKG.description)
    .opt()
        .name('version').title('Version')
        .short('v').long('version')
        .only()
        .flag()
        .act(function() {
            // output the version to stdout instead of stderr if returned
            process.stdout.write(PKG.version + '\n');
            // coa will run `.toString` on the returned value and send it to stderr
            return '';
        })
        .end()
    .opt()
        .name('input').title('Input file, "-" for STDIN')
        .short('i').long('input')
        .arr()
        .val(function(val) {
            return val || this.reject("Option '--input' must have a value.");
        })
        .end()
    .opt()
        .name('string').title('Input SVG data string')
        .short('s').long('string')
        .end()
    .opt()
        .name('folder').title('Input folder, optimize and rewrite all *.svg files')
        .short('f').long('folder')
        .val(function(val) {
            return val || this.reject("Option '--folder' must have a value.");
        })
        .end()
    .opt()
        .name('output').title('Output file or folder (by default the same as the input), "-" for STDOUT')
        .short('o').long('output')
        .arr()
        .val(function(val) {
            return val || this.reject("Option '--output' must have a value.");
        })
        .end()
    .opt()
        .name('precision').title('Set number of digits in the fractional part, overrides plugins params')
        .short('p').long('precision')
        .val(function(val) {
            return !isNaN(val) ? val : this.reject("Option '--precision' must be an integer number");
        })
        .end()
    .opt()
        .name('config').title('Config file or JSON string to extend or replace default')
        .long('config')
        .val(function(val) {
            return val || this.reject("Option '--config' must have a value.");
        })
        .end()
    .opt()
        .name('disable').title('Disable plugin by name, "--disable={PLUGIN1,PLUGIN2}" for multiple plugins (*nix)')
        .long('disable')
        .arr()
        .val(function(val) {
            return val || this.reject("Option '--disable' must have a value.");
        })
        .end()
    .opt()
        .name('enable').title('Enable plugin by name, "--enable={PLUGIN3,PLUGIN4}" for multiple plugins (*nix)')
        .long('enable')
        .arr()
        .val(function(val) {
            return val || this.reject("Option '--enable' must have a value.");
        })
        .end()
    .opt()
        .name('datauri').title('Output as Data URI string (base64, URI encoded or unencoded)')
        .long('datauri')
        .val(function(val) {
            return val || this.reject("Option '--datauri' must have one of the following values: 'base64', 'enc' or 'unenc'");
        })
        .end()
    .opt()
        .name('multipass').title('Pass over SVGs multiple times to ensure all optimizations are applied')
        .long('multipass')
        .flag()
        .end()
    .opt()
        .name('pretty').title('Make SVG pretty printed')
        .long('pretty')
        .flag()
        .end()
    .opt()
        .name('indent').title('Indent number when pretty printing SVGs')
        .long('indent')
        .val(function(val) {
            return !isNaN(val) ? val : this.reject("Option '--indent' must be an integer number");
        })
        .end()
    .opt()
        .name('recursive').title('Use with \'-f\'. Optimizes *.svg files in folders recursively.')
        .short('r').long('recursive')
        .flag()
        .end()
    .opt()
        .name('quiet').title('Only output error messages, not regular status messages')
        .short('q').long('quiet')
        .flag()
        .end()
    .opt()
        .name('show-plugins').title('Show available plugins and exit')
        .long('show-plugins')
        .flag()
        .end()
    .arg()
        .name('input').title('Alias to --input')
        .arr()
        .end()
    .act(function(opts, args) {
        var input = opts.input || args.input,
            output = opts.output,
            config = {};

        // --show-plugins
        if (opts['show-plugins']) {
            showAvailablePlugins();
            return;
        }

        // w/o anything
        if (
            (!input || input[0] === '-') &&
            !opts.string &&
            !opts.stdin &&
            !opts.folder &&
            process.stdin.isTTY === true
        ) return this.usage();

        if (typeof process == 'object' && process.versions && process.versions.node && PKG && PKG.engines.node) {
            var nodeVersion = String(PKG.engines.node).match(/\d*(\.\d+)*/)[0];
            if (parseFloat(process.versions.node) < parseFloat(nodeVersion)) {
                return printErrorAndExit(`Error: ${PKG.name} requires Node.js version ${nodeVersion} or higher.`);
            }
        }

        // --config
        if (opts.config) {
            // string
            if (opts.config.charAt(0) === '{') {
                try {
                    config = JSON.parse(opts.config);
                } catch (e) {
                    return printErrorAndExit(`Error: Couldn't parse config JSON.\n${String(e)}`);
                }
            // external file
            } else {
                var configPath = PATH.resolve(opts.config),
                    configData;
                try {
                    // require() adds some weird output on YML files
                    configData = FS.readFileSync(configPath, 'utf8');
                    config = JSON.parse(configData);
                } catch (err) {
                    if (err.code === 'ENOENT') {
                        return printErrorAndExit(`Error: couldn't find config file '${opts.config}'.`);
                    } else if (err.code === 'EISDIR') {
                        return printErrorAndExit(`Error: directory '${opts.config}' is not a config file.`);
                    }
                    config = YAML.safeLoad(configData);
                    config.__DIR = PATH.dirname(configPath); // will use it to resolve custom plugins defined via path

                    if (!config || Array.isArray(config)) {
                        return printErrorAndExit(`Error: invalid config file '${opts.config}'.`);
                    }
                }
            }
        }

        // --quiet
        if (opts.quiet) {
            config.quiet = opts.quiet;
        }

        // --recursive
        if (opts.recursive) {
            config.recursive = opts.recursive;
        }

        // --precision
        if (opts.precision) {
            var precision = Math.min(Math.max(0, parseInt(opts.precision)), 20);
            if (!isNaN(precision)) {
                config.floatPrecision = precision;
            }
        }

        // --disable
        if (opts.disable) {
            changePluginsState(opts.disable, false, config);
        }

        // --enable
        if (opts.enable) {
            changePluginsState(opts.enable, true, config);
        }

        // --multipass
        if (opts.multipass) {
            config.multipass = true;
        }

        // --pretty
        if (opts.pretty) {
            config.js2svg = config.js2svg || {};
            config.js2svg.pretty = true;
            var indent;
            if (opts.indent && !isNaN(indent = parseInt(opts.indent))) {
                config.js2svg.indent = indent;
            }
        }

        svgo = new SVGO(config);

        // --output
        if (output) {
            if (input && input[0] != '-') {
                if (output.length == 1 && checkIsDir(output[0])) {
                    var dir = output[0];
                    for (var i = 0; i < input.length; i++) {
                        output[i] = checkIsDir(input[i]) ? input[i] : PATH.resolve(dir, PATH.basename(input[i]));
                    }
                } else if (output.length < input.length) {
                    output = output.concat(input.slice(output.length));
                }
            }
        } else if (input) {
            output = input;
        } else if (opts.string) {
            output = '-';
        }

        if (opts.datauri) {
            config.datauri = opts.datauri;
        }

        // --folder
        if (opts.folder) {
            var ouputFolder = output && output[0] || opts.folder;
            return optimizeFolder(config, opts.folder, ouputFolder).then(noop, printErrorAndExit);
        }

        // --input
        if (input) {
            // STDIN
            if (input[0] === '-') {
                return new Promise((resolve, reject) => {
                    var data = '',
                        file = output[0];

                    process.stdin
                        .on('data', chunk => data += chunk)
                        .once('end', () => processSVGData(config, {input: 'string'}, data, file).then(resolve, reject));
                });
            // file
            } else {
                return Promise.all(input.map((file, n) => optimizeFile(config, file, output[n])))
                    .then(noop, printErrorAndExit);
            }

        // --string
        } else if (opts.string) {
            var data = decodeSVGDatauri(opts.string);

            return processSVGData(config, {input: 'string'}, data, output[0]);
        }
    });

/**
 * Change plugins state by names array.
 *
 * @param {Array} names plugins names
 * @param {Boolean} state active state
 * @param {Object} config original config
 * @return {Object} changed config
 */
function changePluginsState(names, state, config) {
    names.forEach(flattenPluginsCbk);

    // extend config
    if (config.plugins) {
        for (var name of names) {
            var matched = false,
                key;

            for (var plugin of config.plugins) {
                // get plugin name
                if (typeof plugin === 'object') {
                    key = Object.keys(plugin)[0];
                } else {
                    key = plugin;
                }

                // if there is such a plugin name
                if (key === name) {
                    // don't replace plugin's params with true
                    if (typeof plugin[key] !== 'object' || !state) {
                        plugin[key] = state;
                    }
                    // mark it as matched
                    matched = true;
                }
           